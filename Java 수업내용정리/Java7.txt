1. 클래스 메소드(static method)
(전역변수, 전역함수를 만들 때 사용) - 모든 클래스에서 공유하는느낌... 따라서 객체가아니다!!
변수도 클래스변수가있듯이 클래스에도 클래스메소드가 있을 수 있다.

인스턴스에서는 객체를 생성하지않고 static에 접근가능
ex) String

static메소드안에서는 객체변수 접근이 불가능... 객체메소드도 접근이 불가능....
(인스턴스변수나 인스턴스메소드에 대한 객체를 생성하지않았기 때문에 접근 못하는것은 당연)

static메소드에서는 this 사용불가
(static은 클래스지 객체가 아니기 때문)




2. 생성자
ex) Book b = new Book()

new 연산자와 같이 사용되어 클래스로부터 객체를 생성할때 호출되고 객체의 초기화를 담당
메소드가 객체의 기능을 구현하는데에 사용이된다면, 생성자는 객체 생성시에 Book() 안에 객체의 값을 넣어줄수있다.
물론, Book()안에 아무 값도 안넣는다면 기본 값(숫자는0,문자는null)으로 객체가 생성된다.
(생성자로 안쓴다면, setter를 사용해서 값을 넣어줄수도있음)

" 모든 클래스는 하나 이상의 생성자가 있어야한다. "
생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
(생성자를 하나도 안만들어주면 자바에서 자동으로 기본생성자를 만들어줌. 그래서 우리가 생성자가 있는지 몰랐던것)
(임의로 생성자를 만들면 기본생성자는 사라지기 때문에 직접 기본생성자를 만들어줘야함)


생성자의 이름은 클래스의 이름과 같아야한다.

생성자는 리턴값이 없다(하지만 void를 쓰지 않는다).

new 뒤에 객체를 생성할때에만 쓸 수 있다.



3. 생성자 오버로딩 (다형성)
다형성 : 하나의 생성자를 만들어서 여러 객체를 생성 할 수 있다. (파라미터를 다르게 주는 방법으로)
오버로딩 : 하나의 클래스에서 일어남 ( <-> 오버라이딩 - 상속관계에서 일어남)



4. 메소드 오버로딩 (다형성)
하나의 클래스에 같은 이름의 메소드가 여러 개 존재할 수 있다.
But, 그 메소드들은 매개변수의 타입, 개수, 그리고 순서가 다른 형태로 구별된다(동일한 이름의 상이한 시그너처).



5. 왜 상속을 하는가?
부모클래스(필드, 메소드) -> 자식클래스가 물려받음

ex)
Person클래스에 있는 메소드 => 말하기() 먹기() 잠자기()
Student클래스에 있는 메소드 => 말하기() 먹기() 잠자기() 공부하기()
StudentWorker에 있는 메소드 => 말하기() 먹기() 잠자기() 공부하기() 일하기()

상속받는 메소드는 위처럼 쓸 필요없고 부모클래스가 갖는 메소드중 중복되는걸 생략가능 (코드의 재사용)
(이후에 배울, 상속에서의 확장성(override)이 진짜 객체지향의 꽃임)



6. 상속의 특징
부모는 무조건 하나! (자식은 여러명 가능)

자바 계층구조의 최상위 클래스는 java.lang.Object이다.

부모의 접근제어자가 protected인 것은 자식이 물려받을 수 있다.



7. 다형성 : 메소드 오버라이딩 (객체지향의 꽃)
ex)
점을 찍는 Point클래스와, (Point를 상속받는)컬러를 찍는 ColorPoint클래스가 있고
Main클래스에 각 객체를 불러온다고했을때

1) ColorPoint pt2 = new ColorPoint();
2) Point pt2 = new ColorPoint();
두 객체생성의 차이에서 오버라이딩의 필요성이 나옴

1번처럼 하면 컬러포인트를 찍는 메소드를 또 추가해줘야함
하지만 2번처럼 하면 기존에 있던 포인트 메소드를 그대로 쓸수 있음

